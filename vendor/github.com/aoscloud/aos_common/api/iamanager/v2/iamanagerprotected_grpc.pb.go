// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package iamanager

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IAMProtectedServiceClient is the client API for IAMProtectedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMProtectedServiceClient interface {
	SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error)
	ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error)
	EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	RegisterInstance(ctx context.Context, in *RegisterInstanceRequest, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
	UnregisterInstance(ctx context.Context, in *UnregisterInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type iAMProtectedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMProtectedServiceClient(cc grpc.ClientConnInterface) IAMProtectedServiceClient {
	return &iAMProtectedServiceClient{cc}
}

func (c *iAMProtectedServiceClient) SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/SetOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error) {
	out := new(CreateKeyResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/CreateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error) {
	out := new(ApplyCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/ApplyCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/EncryptDisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/FinishProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) RegisterInstance(ctx context.Context, in *RegisterInstanceRequest, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) UnregisterInstance(ctx context.Context, in *UnregisterInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v2.IAMProtectedService/UnregisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMProtectedServiceServer is the server API for IAMProtectedService service.
// All implementations must embed UnimplementedIAMProtectedServiceServer
// for forward compatibility
type IAMProtectedServiceServer interface {
	SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error)
	Clear(context.Context, *ClearRequest) (*empty.Empty, error)
	CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error)
	ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error)
	EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error)
	FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error)
	RegisterInstance(context.Context, *RegisterInstanceRequest) (*RegisterInstanceResponse, error)
	UnregisterInstance(context.Context, *UnregisterInstanceRequest) (*empty.Empty, error)
	mustEmbedUnimplementedIAMProtectedServiceServer()
}

// UnimplementedIAMProtectedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMProtectedServiceServer struct {
}

func (UnimplementedIAMProtectedServiceServer) SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOwner not implemented")
}
func (UnimplementedIAMProtectedServiceServer) Clear(context.Context, *ClearRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedIAMProtectedServiceServer) CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}
func (UnimplementedIAMProtectedServiceServer) ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCert not implemented")
}
func (UnimplementedIAMProtectedServiceServer) EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptDisk not implemented")
}
func (UnimplementedIAMProtectedServiceServer) FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishProvisioning not implemented")
}
func (UnimplementedIAMProtectedServiceServer) RegisterInstance(context.Context, *RegisterInstanceRequest) (*RegisterInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterInstance not implemented")
}
func (UnimplementedIAMProtectedServiceServer) UnregisterInstance(context.Context, *UnregisterInstanceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterInstance not implemented")
}
func (UnimplementedIAMProtectedServiceServer) mustEmbedUnimplementedIAMProtectedServiceServer() {}

// UnsafeIAMProtectedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMProtectedServiceServer will
// result in compilation errors.
type UnsafeIAMProtectedServiceServer interface {
	mustEmbedUnimplementedIAMProtectedServiceServer()
}

func RegisterIAMProtectedServiceServer(s grpc.ServiceRegistrar, srv IAMProtectedServiceServer) {
	s.RegisterService(&IAMProtectedService_ServiceDesc, srv)
}

func _IAMProtectedService_SetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).SetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/SetOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).SetOwner(ctx, req.(*SetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).Clear(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).CreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/CreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).CreateKey(ctx, req.(*CreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_ApplyCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).ApplyCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/ApplyCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).ApplyCert(ctx, req.(*ApplyCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_EncryptDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).EncryptDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/EncryptDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).EncryptDisk(ctx, req.(*EncryptDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_FinishProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).FinishProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/FinishProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).FinishProvisioning(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/RegisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).RegisterInstance(ctx, req.(*RegisterInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_UnregisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).UnregisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v2.IAMProtectedService/UnregisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).UnregisterInstance(ctx, req.(*UnregisterInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMProtectedService_ServiceDesc is the grpc.ServiceDesc for IAMProtectedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMProtectedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v2.IAMProtectedService",
	HandlerType: (*IAMProtectedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetOwner",
			Handler:    _IAMProtectedService_SetOwner_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _IAMProtectedService_Clear_Handler,
		},
		{
			MethodName: "CreateKey",
			Handler:    _IAMProtectedService_CreateKey_Handler,
		},
		{
			MethodName: "ApplyCert",
			Handler:    _IAMProtectedService_ApplyCert_Handler,
		},
		{
			MethodName: "EncryptDisk",
			Handler:    _IAMProtectedService_EncryptDisk_Handler,
		},
		{
			MethodName: "FinishProvisioning",
			Handler:    _IAMProtectedService_FinishProvisioning_Handler,
		},
		{
			MethodName: "RegisterInstance",
			Handler:    _IAMProtectedService_RegisterInstance_Handler,
		},
		{
			MethodName: "UnregisterInstance",
			Handler:    _IAMProtectedService_UnregisterInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v2/iamanagerprotected.proto",
}
